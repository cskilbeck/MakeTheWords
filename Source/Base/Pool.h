//////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////

struct PoolFake : list_node<PoolFake>
{
};

//////////////////////////////////////////////////////////////////////

template <typename T> struct Pool
{
	byte *mPool;
	linked_list<PoolFake> mFreeList;

	static_assert(sizeof(PoolFake) <= sizeof(T), "Can't make a Pool of object < 8 bytes big");

	//////////////////////////////////////////////////////////////////////

	Pool() : mPool(null)
	{
	}

	//////////////////////////////////////////////////////////////////////

	Pool(int numItems) : mPool(null)
	{
		Resize(numItems);
	}

	//////////////////////////////////////////////////////////////////////

	~Pool()
	{
		Clear();
	}

	//////////////////////////////////////////////////////////////////////

	void Clear()
	{
		SafeDeleteArray(mPool);
		mFreeList.clear();
	}

	//////////////////////////////////////////////////////////////////////

	void Resize(int numItems)
	{
		Clear();
		mPool = new byte[numItems * sizeof(T)];
		for(int i=0; i<numItems; ++i)
		{
			mFreeList.push_back(reinterpret_cast<PoolFake *>(mPool + i * sizeof(T)));
		}
	}

	//////////////////////////////////////////////////////////////////////

	T *Alloc()
	{
		return reinterpret_cast<T *>(mFreeList.pop_back());
	}

	//////////////////////////////////////////////////////////////////////

	void Free(T *o)
	{
		mFreeList.push_back(reinterpret_cast<PoolFake *>(o));
	}
};

//////////////////////////////////////////////////////////////////////
